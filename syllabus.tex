\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\usepackage{caption}
\usepackage{color}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue},
  captionpos=b,
  breaklines=true,
  backgroundcolor=\color{lightgray},
  columns=fullflexible,
}
\lstdefinelanguage{javascript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}


% *** GRAPHICS RELATED PACKAGES ***
%\usepackage[pdftex]{graphicx}
\usepackage{graphicx}
%\usepackage[dvips]{graphicx}
% to place figures on a fixed position
\usepackage{float}

\usepackage[margin=1in]{geometry}

\title{Blockchains for Industrial IoT - a Tutorial}

\author{Pal Varga and Ferenc Janky \\ Budapest University of Technology and Economics}

\date{v0.92 \\ 2019}

\begin{document}

\maketitle

\begin{abstract}
Utilizing Blockchains within the Internet of Things (IoT) concept is quite a recent idea. There are already a number of use cases and supporting frameworks available, which shows its potential benefits for many domains.

There are interesting, business-driven target areas within the Industrial IoT domain, including sectors such as supply chain (including manufacturing, transportation and logistics), maintenance, energy trading, grids, and even healthcare. When compared to consumer IoT, these systems have special requirements: certain level of real-time, security, engineering complexity, multi-stakeholder visibility, fast transaction and asset traceability. While the Distributed Ledger Technology (DLT) already addresses some areas of these (such as multi-stakeholder visibility or asset traceability), Blockchain Technology (BCT) provides additional value for security, building trust, and reducing cost while accelerating transactions of service agreements.
This tutorial aims to reveal the opportunities and challenges as well as presenting real-life examples together with network management aspects. First it provides an overview and definitions the BCT universe – from Assets and Blocks through Consensus Mechanisms and Distributed Ledgers to Wallets. Next, it describes some special requirements of the Industrial IoT domain together with ideas of utilizing BCT to cover these needs. While discussing benefits, the tutorial reveals some drawbacks as well. These help us answering the questions: when is it beneficial to use BCT, when is it questionable, and when is it avoidable?

Furthermore, the tutorial provides insights on various use-cases of employing BCT and smart service contracts in healthcare, electricity trading, production, asset tracking or proactive maintenance. Aside from being interesting simply because they are becoming core technologies of near-future systems, IIoT and Blockchains have a network management viewpoint as well. The IIoT end-devices need on-boarding, their data needs to be secured, authenticity needs to be checked, and trust needs to be built – all of which tasks BCT can be utilized effectively. Moreover, as part of configuration management, reliable and secure firmware distribution and upgrade can be supported inherently.

The hands-on part of this tutorial includes a multi-player bidding scenario.  In here, the users (consumers) can deploy smart service contracts on in an Ethereum-based blockchain, stating their need of given amount of energy at a maximum price. The energy-provider type of players in this scenario can bid on winning the contract. The various transactions related to the bidding, energy consumption and withdrawal of gains can be followed by the players either by using the GUI provided, or by issuing commands for reading transaction parameters and service contract values stored at the blockchain.

\end{abstract}

\newpage

\tableofcontents

%\newpage

\section{Introduction}

This tutorial provides a generic overview of Blockchain Technology and its feasibility for the  Industrial Internet of Things (IIoT) domain. The tutorial itself consist of three parts: (i) an oral lecture with its separate presentation material, (ii) the current syllabus providing support background material for (iii) the demo on using smart service contracts in a multi-player bidding scenario.

In order to get a proper grip on the tutorial exercises, some of the main concepts of the Blockchain Technology, the Distributed Ledgers, and the Smart Service Contract are described here.
Beside this, some of the application areas of these concepts for Industrial Internet of Things (IIoT) are discussed in brief.

The presentation material is also available for this tutorial, at ...

The demo application for the multi-player bidding scenario is available at ...


\section{Motivation: using Blockchains for Industrial IoT}

\subsection{General considerations}

The domain of Industrial IoT is growing in terms of endpoint numbers, application functions, and multi-player usage scenarios -- among others. When compared to public IoT approaches, the industrial domain proceeds with a much smoother pace, but with great mass -- so its momentum (the product of mass and velocity) is huge, as well. There are several reasons why industry adopts IoT in a more conservative way, including the requirements for real-time operation, security and safety, high reliability, complexity, engineering efficiency, return of investment, and not to forget: trust. It takes time to address all these at once; and it is very risky at any industrial partner to introduce a technological approach for which not all the elements are fully tested -- especially if their current systems function well, although not optimally.

The technical requirements are already available for everyone who wish to adopt IIoT solutions; and those at the forefront of Industry4.0 movement, has already started to do so. It is the non-technical terms -- e.g., return of investment and trust -- that are hard to justify for every paradigm shift.

Trust among new partners is currently built through the involvement of legal and financial authorities. These introduce background checks, and issue mitigation processes if a new partnership ends up on a wrong track. The involvement of authorities seems necessary, but it does slow the process down, and it has its financial price as well. There is a more traditional way of getting trust: building it slowly by partners (and their trusted ecosystems) working together from smaller towards greater ventures.

The immutable feature of distributed legders, and heir verification through blockchain technology make it possible to leave out certain authorities from the "trust-building" process. Together with smart service contracts, the use of private blockchains within industrial partnerships or ecosystems make transactions fast, secure, safe, trusted, validated and immutable throughout the various supply chains. 

While the current tutorial merely provides an overview and a few hands-on demonstrations on the above issues and solutions, readers are encouraged to study the current surveys on the details of IoT blockchain technologies \cite{BC_IoT_survey} as well as their comprehensive comparisons and applications \cite{BC_IoT_comprehensive}.

\subsection{IoT security: a brief overview on issues and solutions}

There are various known security issues at each layer of the IoT infrastructure. These can be mapped to data security principles -- Confidentiality, Integrity, Availability. Figure~\ref{fig:IoT_Layers} depicts an approach where each layer has different security issues and measures, and operated by different players of the IoT infrastructure, so the have separated mitigation policies. Figure~\ref{fig:IoT_Table} provides an overview of these security categories and their mitigation policies.

\begin{figure}[H]
    \begin{minipage}{0.48\textwidth}
     \centering
     \includegraphics[width=0.95\textwidth]{figures/IoT_Layers.png}
     \caption{IoT infrastructure layers -- for security assessment \cite{IoT_Security}}
     \label{fig:IoT_Layers}
    \end{minipage}\hfill    
%\end{figure}
%\begin{figure}[H]
    \begin{minipage}{0.48\textwidth}
     \centering
     \includegraphics[width=0.95\textwidth]{figures/IoT_Security_Layer_Table.png}
     \caption{Security issue categories and their mitigation - and overview \cite{IoT_Security}}
     \label{fig:IoT_Table}
    \end{minipage}\hfill
\end{figure}

\subsection{Special features of Blockchains to be utilized by IIoT}

\subsubsection{Interoperability across IoT devices, IoT systems and industrial sectors}

IoT data is produced and consumed at various levels of the ecosystem. Various requirements, including real-time, QoS, security, and engineering efficiency necessitate to provide borders around elements of the IoT infrastructure, within which these requirements can be satisfied when compared to the borderless scenario. Automation or IoT local clouds can be formed based on physical or logical closeness. 

It was the Arrowhead framework for industrial IoT that first defined these local clouds \cite{Arrowhead_Interoperability}, within which the interoperability of elements was based on service oriented architecture principles.

Figure \ref{fig:IIoT_intercloud} depicts how the IEC IIoT reference architecture -- with Edge, Platform and Enterprise Levels -- can be covered by the Local Clouds, and its inter-cloud communication of the Arrowhead framework.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{figures/Arrowhead-IIoT.png}
    \caption{The IEC IIoT Reference Architecture mapped for Arrowhead Local Clouds \cite{IIoT_intercloud}}
    \label{fig:IIoT_intercloud}
\end{figure}

While discovery, loose coupling and late binding are provided through the service oriented architecture approach, there are no mechanisms built in for transaction logging, smart service contract handling, or data traceability -- these need to be tackled by further solutions.  

\subsubsection{Traceability and Reliability of IoT data}

While interoperability among IoT systems can be supported by frameworks such as Arrowhead, traceability and reliability of IoT data are still issues to be solves. Distributed ledgers and blockchain technology can provide proper answers to these.

In this context, according to \cite{BC_IoT_survey}, Traceability is the capability of tracing and verifying the spatial and temporal information of a data block saved in the blockchain. Each data block saved in a blockchain is attached with a historic timestamp consequently assuring the data traceability. 

Reliability of IoT data \cite{BC_IoT_survey} is the quality of IoT data being trustworthy. It can be ensured by the integrity enforced by crytographic mechanisms including asymmetric encryption algorithms, hash functions and digital signature, all of which are inherent in blockchains.

\subsubsection{Improved Security of IoT system-of-systems through blockchains}
Although it is not the basic feature of the blockchain, but its message (or transacuion) initiation procedure, the data gets written to the blockchain by using PKI technologies, which covers the \emph{Confidentiality} principle.

Due to the immutable nature of data stored at the distributed ledgers, the \emph{Integrity} principle of data security gets covered -- securing against tampering, or any sorts of modifications. Furthermore, the blockchain protects for traceability.

The \emph{Availability} principle is supported by the distributed nature of the ledger, as a trusted database.

\subsection{When is it beneficial to use BCT for IIoT?}

Figure~\ref{fig:BC_Do_You_Need} depicts one of the rule-of-the-thumb decision diagrams on the topic.
%\begin{lstlisting}[language=python,frame=single,breaklines]
%packet = event.parsed  
%\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/DoYouNeedBC.jpg}
    \caption{Do You Need to use Blockchains? (by Jeremy Gardner, 2018)}
    \label{fig:BC_Do_You_Need}
\end{figure}


\subsection{Precautions for Blockchain usage}

While blockchains and their related technologies can provide answers to several issues related to security, anonymity and data privacy, trust, accelerated transactions, micropayments, cost reductions by removing middlemen, ledgers as distributed and trusted databases, etc., they also raise issues that need to be covered before their wide and unquestioned use in the Industrial IoT domain.

First, there is an issue with the number of transactions per second. The current, widely used blockchains can provide a few tens of transactions per second -- whereas the industrial need is more oin the thousands of transactions per second range. 

Second, the mixed usage of private and public blockchains are not clearly solved in practice. While the ecosystems of given supply chains can use private blockchains, they may not easily mix with other blockchains of other private ecosystems, not to mention public blockchains and their access rights. Moreover, there is a scalability dilemma between public and private blockchains as well.

Third, security. It sounds unreasonable -- too costly -- to tamper around blockchain data; but it is not impossible. Where the stakes are high, the weakest link of the chain can be a blockchain as well; with its known vulnerabilities: the 51\% attack, the race attack, finney attacks, hidden bugs in smart contracts, just to mention a few.

Fourth, the legal issues. While it seems a clear advantage (in price, speed and flexibility) of not using central authorities in a multi-stakeholder environment, we are talking about rigid company structures with personal responsibilities, at the same time. It requires a hih amount of confidence in the technology as well as the legal consequences of tampering blockchain-stored data. As they say, you cannot solve social issues by using technology.



\section{Blockchain-related concepts}

This subsection aims to provide some basic references related to Blockchains. This document merely provides some initial definition together with citing references that further elaborate either the whole topic or the given term. Providing a comprehensive overview of the terms is outside of the scope of this document.

Nevertheless, readers are encouraged to check out the cited further resources and targeted tutorials on these concepts. The cited references are deliberately chosen from various sources to show the wide range of tutorial materials available for readers at various levels of interest. 

\subsection{Blockchain}
As $techterms.com$ \cite{techterms} defines (with slight additions):
\begin{quote}
    "A blockchain is a digital record of transactions. The name comes from its structure, in which individual records, called blocks, are linked together in single list, called a chain. Blockchains are used for recording transactions made with cryptocurrencies, such as Bitcoin, and have many other applications -- including smart service contracts for IoT.
    
    Each transaction added to a blockchain is validated by multiple computers on the Internet or on intranets of private operators. These systems, which are configured to monitor specific types of blockchain transactions, form a peer-to-peer network. They work together to ensure each transaction is valid before it is added to the blockchain. This decentralized network of computers ensures a single system cannot add invalid blocks to the chain.
    
    When a new block is added to a blockchain, it is linked to the previous block using a cryptographic hash generated from the contents of the previous block. This ensures the chain is never broken and that each block is permanently recorded. It is also intentionally difficult to alter past transactions in blockchain since all the subsequent blocks must be altered first."
\end{quote}

\subsubsection{A sample workflow of Blockchain-related processes}

Figure~\ref{fig:BC_Workflow} depicts a sample workflow.
%\begin{lstlisting}[language=python,frame=single,breaklines]
%packet = event.parsed  
%\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{figures/sample_BC_flow.png}
    \caption{A typical workflow of a Blockchain-related process (https://steemit.com/blockchain/)}
    \label{fig:BC_Workflow}
\end{figure}

\subsubsection{Distributed Ledger Technology}
The distributed ledger database is spread across several nodes (devices) on a peer-to-peer network, where each replicates and saves an identical copy of the ledger and updates itself independently. The primary advantage is the lack of central authority. When a ledger update happens, each node constructs the new transaction, and then the nodes vote by consensus algorithm on which copy is correct. Once a consensus has been determined, all the other nodes update themselves with the new, correct copy of the ledger \cite{DLT}.


\subsubsection{Cryptographic Hash Function}
The reason to apply "hashing" on data (or the "message") put on the blockchin is making it secret so only those with proper access rights can read it, and second, making it immutable: if the message is modified, the hash value will change. After such change, it is impossible to reconstruct the original message.

A cryptographic hash function (CHF) is a hash function that is suitable for use in cryptography. It is a mathematical algorithm that maps data of arbitrary size to a bit string of a fixed size (the "hash value", "hash", or "message digest") and is a one-way function, that is, a function which is practically infeasible to invert \cite{CHF}.

\subsubsection{Mining}

Once a message is hashed, it gets broadcasted among all the mining nodes so it would become part of a block on the chain. Mining is the process of adding transaction records to a ledger of past transactions --, i.e., the blockchain. The blockchain serves to confirm transactions to the rest of the network as having taken place. 

As the network nodes are widely distributed, every miner in the network is expected to receive multiple messages from multiple vendors at any given period of time. What the miner does is he combines these messages in a single block \cite{tutorialspoint}.

The primary purpose of mining is to set the history of transactions in a way that is computationally impractical to modify by any one entity. By downloading and verifying the blockchain, the nodes are able to reach consensus about the ordering of events. 

Mining is intentionally designed to be resource-intensive and difficult so that the number of blocks found each day by miners remains steady. Individual blocks must contain a proof (e.g. proof of stake, proof of stake, etc.) to be considered valid. This proof is verified by other blockchain nodes each time they receive a block \cite{bitcoin_wiki}.

\subsubsection{Consensus algorithms}
One of the outcomes of the mining procedure is to validate the transactions of a block. As part of this, miners are working to find a $nonce$ that shows that the block hash satisfies an earlier-defined, well-known target criterion.

The Proof of Work (PoW) is a popular consensus algorithm; and as such, it is aimed for resolving the problem of reliability in a network involving multiple unreliable nodes. The PoW is deliberately computationally intensive for miners. It is a piece of data which is difficult (costly, time-consuming) to produce but easy for others to verify and which satisfies certain requirements. Producing a proof of work can be a random process with low probability so that a lot of trial and error is required on average before a valid proof of work is generated \cite{tutorialspoint}, \cite{bitcoin_wiki}.

There are several other consensus algorithms exists \cite{consensus}, one of the well known ones beside PoW (used by e.g. Bitcoin) is Proof of Stake (used by e.g. Ethereum), where the creator of the next block is called "validator" (instead of miner) and is chosen via various combinations of random selection and wealth or age (i.e., the stake).  
%\subsubsection{Practical Byzantine Tault Tolerance}

\subsubsection{Merkle Tree}

In order to help compressing blockchain data for those nodes who are not interested in mining, but only exchanging goods, writing messages on the blockchain and checking whether a transaction is valid that is on the blockchain, the binary Merkle Hash Tree (see Figure~\ref{fig:merkle}) can be used.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/merkle_tree.jpg}
    \caption{Merkle Tree \cite{tutorialspoint}}
    \label{fig:merkle}
\end{figure}

When transactions hashed into a Merkle Tree, the client merely need to have the Previous hash, the Merkle Root, and the Nonce for Each Block header - as Figure~\ref{fig:merkle_verif} shows. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/payment_verification.jpg}
    \caption{Transaction verification by using the Merkle Root \cite{tutorialspoint}}
    \label{fig:merkle_verif}
\end{figure}

In order to verify certain transactions made in the past, the Merkle Roots and corresponding hashes need to be used instead of all hashes for the given transactions on the block \cite{IOTA_Merkle}. 



\subsection{Smart Contracts}

According to Wikipedia, \cite{Wiki_SC} A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible.

There are various kinds of contractual clauses may be made partially or fully self-executing, self-enforcing, or both. The aim of smart contracts is to provide security that is superior to traditional contract law and to reduce other transaction costs associated with contracting. See Figure \ref{fig:smartcontracts} for some of the main features of smart contracts on blockchains.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/smart-contracts-01.png}
    \caption{Smart contracts on the blockchain}
    \label{fig:smartcontracts}
\end{figure}


The idea of smart contracts were first proposed by Nick Szabo -- who, by the way, has Hungarian origins, as well.


\section{Smart contracts using Ethereum}

Within the Ethereum framework Smart Contracts are implemented in the form of Decentralized Applications - DApp. These DApps are defined using a higher level programming language that is either:
\begin{itemize}
    \item Solidity, that is a statically typed programming language showing similarities to Javascript, C++ and other high level, object oriented languages \cite{solidity_manual}
    \item Vyper, which is a Python based language still under development \cite{vyper_doc}
\end{itemize}

Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs which govern the behaviour of accounts within the Ethereum state. Solidity was influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM).
Solidity is statically typed, supports inheritance, libraries and complex user-defined types among other features. With Solidity you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.\cite{solidity_manual}

The process of how a smart contract is synthesized into "executable code" is somewhat similar to other well known paradigms of other high level programming languages. The contract code is compiled to low-level, assembly like code that is executed by the Ethereum Virtual Machine (EVM). The data and code is stored on the blockchain, the code can be called using a well known ABI that corresponds to an API that can also be used in the higher level programming language. etc.

Smart contracts define the data and the protocol on how that data can be changed. Actually since one key feature is that blockchains are immutable, change might not be the appropriate term for that but more like how the data should be transformed to get in to a next valid state. This is analogous to various well established immutable algorithms and data structures used in pure functional programming, such as persistent list, m-trie, etc. 

%Add figure on how this adds up

%\subsubsection{Simplified concept of Smart Contract operation}

In the following figures we summarize a simplified concept of Smart Contract operation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/deploy_0.png}
    \caption{User constructs smart contract, VM deploys it onto the chain}
    \label{fig:deploy_0}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/deploy_1.png}
    \caption{User calls a function of the smart contract, VM executes code, creates transaction, mines block onto the chain}
    \label{fig:deploy_1}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/deploy_2.png}
    \caption{Another user calls a different function, at every point of time, orange data members indicate a valid state of the contract object}
    \label{fig:deploy_2}
\end{figure}

%\subsection{Solidity basics}



\iffalse
\begin{comment}
\textbf{TODO: clean this up, add more references}


Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables and functions that can modify these variables. Calling a function on a different contract (instance) will perform an EVM function call and thus switch the context such that state variables are inaccessible. A contract and its functions need to be called for anything to happen. There is no “cron” concept in Ethereum to call a function at a particular event automatically.

Contracts can be created “from outside” via Ethereum transactions or from within Solidity contracts.

IDEs, such as Remix, make the creation process seamless using UI elements.

Creating contracts programmatically on Ethereum is best done via using the JavaScript API web3.js. It has a function called web3.eth.Contract to facilitate contract creation.

When a contract is created, its constructor (a function declared with the constructor keyword) is executed once.
A constructor is optional. Only one constructor is allowed, which means overloading is not supported.

After the constructor has executed, the final code of the contract is deployed to the blockchain. This code includes all public and external functions and all functions that are reachable from there through function calls. The deployed code does not include the constructor code or internal functions only called from the constructor.

Internally, constructor arguments are passed ABI encoded after the code of the contract itself, but you do not have to care about this if you use web3.js\cite{web3_api}.

Solidity is a statically typed language, which means that the type of each variable (state and local) needs to be specified. Solidity provides several elementary types which can be combined to form complex types.

The concept of “undefined” or “null” values does not exist in Solidity, but newly declared variables always have a default value dependent on its type. To handle any unexpected values, you should use the revert function to revert the whole transaction, or return a tuple with a second bool value denoting success.

Value Types
Fixed Point Numbers
Address address: Holds a 20 byte value (size of an Ethereum address).
address payable: Same as address, but with the additional members transfer and send
Contract Types
Fixed-size byte arrays
Function Types

Function types are the types of functions. Variables of function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. Function types come in two flavours - internal and external functions:

Internal functions can only be called inside the current contract (more specifically, inside the current code unit, which also includes internal library functions and inherited functions) because they cannot be executed outside of the context of the current contract. Calling an internal function is realized by jumping to its entry label, just like when calling a function of the current contract internally.

External functions consist of an address and a function signature and they can be passed via and returned from external function calls.

Function types are notated as follows:

function (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]

Reference Types

Values of reference type can be modified through multiple different names. Contrast this with value types where you get an independent copy whenever a variable of value type is used. Because of that, reference types have to be handled more carefully than value types. Currently, reference types comprise structs, arrays and mappings. If you use a reference type, you always have to explicitly provide the data area where the type is stored: memory (whose lifetime is limited to a function call), storage (the location where the state variables are stored) or calldata (special data location that contains the function arguments, only available for external function call parameters).

An assignment or type conversion that changes the data location will always incur an automatic copy operation, while assignments inside the same data location only copy in some cases for storage types.
Data location

Every reference type, i.e. arrays and structs, has an additional annotation, the “data location”, about where it is stored. There are three data locations: memory, storage and calldata. Calldata is only valid for parameters of external contract functions and is required for this type of parameter. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.

Data location and assignment behaviour

Data locations are not only relevant for persistency of data, but also for the semantics of assignments:

    Assignments between storage and memory (or from calldata) always create an independent copy.
    Assignments from memory to memory only create references. This means that changes to one memory variable are also visible in all other memory variables that refer to the same data.
    Assignments from storage to a local storage variable also only assign a reference.
    All other assignments to storage always copy. Examples for this case are assignments to state variables or to members of local variables of storage struct type, even if the local variable itself is just a reference.

Structs
Solidity provides a way to define new types in the form of structs, which is shown in the following example:
Mapping Types.


You declare mapping types with the syntax mapping(KeyType => ValueType). The KeyType can be any elementary type. This means it can be any of the built-in value types plus bytes and string. User-defined or complex types like contract types, enums, mappings, structs and any array type apart from bytes and string are not allowed. ValueType can be any type, including mappings.


You can think of mappings as hash tables, which are virtually initialised such that every possible key exists and is mapped to a value whose byte-representation is all zeros, a type’s default value. The similarity ends there, the key data is not stored in a mapping, only its keccak256 hash is used to look up the value.

Because of this, mappings do not have a length or a concept of a key or value being set, and therefore cannot be erased without extra information regarding the assigned keys (see Clearing Mappings).

Constructor, method, view, nonpayable, payable, data types, storage locations, best practices, references 

Development (mention remix IDE)
\fi

\section{Introduction to the demo environment}

The following tools are \textbf{required} in order to effectively participate in the tutorial
\begin{itemize}
    \item Web browser supporting ECMAScript 2015
    \item SSH client (e.g. \emph{putty} on windows, \emph{openssh} on linux
    \item Arbitrary text editor for Solidity smart contract editing
\end{itemize}{}

The \href{https://blockchain.cnsm2019-tutorial.com/}{demo environment} - as illustrated by Figure \ref{fig:demo-env} - consists of a Web UI and back-end for managing the training sessions and allowing that the participants can easily interact with each other's deployed contracts.The back-end interacts with the Etherum based blockchain network using web3 API. The blockchain network consists only one node for now, but that doesn't greatly affects how the endpoints would interact with the blockchain network as long as connection is available to a node.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/env.png}
    \caption{The tutorial environment}
    \label{fig:demo-env}
\end{figure}

\subsection{Login details}

\begin{itemize}
\item Demo environment: \url{https://blockchain.cnsm2019-tutorial.com/}
\begin{itemize}
\item username: \verb!user<X>! , where is \verb!<X>! is a number,  e.g.: \verb!user11!, the number allocation will happen at the time of starting the hands-on exercises
\item password: same as the username, e.g \verb!user11!
\end{itemize}
\item SSH access details:
\begin{itemize} 
\item host: blockchain.cnsm2019-tutorial.com
\item port: 2222
\item username: tutorial
\item password: cnsm2019
\end{itemize}
\end{itemize}

\subsection{Attaching to \emph{geth} node}

\begin{itemize}
\item SSH onto host specified above
\item Attach to \emph{geth} blockchain node by issueing command \verb!sudo ./admin/geth_attach!
\item the \emph{tutorial} user's password has to be given again
\end{itemize}

\subsection{Most frequently used \emph{geth} commands}

\begin{itemize}
\item the \emph{geth} console is a javascript REPL, any valid Javascript code is accepted. The commands below are actually \emph{web3} API calls, for all available commands see \url{https://web3js.readthedocs.io/en/v1.2.1/getting-started.html}

\item \verb!<variable name> = <expression>! assigns the result of expression  \verb!<expression>! to the variable named \verb!<variable>!, e.g. \verb!block34 = eth.getBlock(34)! that means assign the block object of block 34 to the variable named \verb!block34!


\item to define any custom function define a Javascript function and assign it to a variable:

\begin{lstlisting}[language=javascript]
myFunction = function(param1,param2,...) {
 // body of the function
}

// call the function with arguments
myFunction(arg1,arg2,...)
\end{lstlisting}


\item \verb!eth.getBalance(<account>)! for checking the balance of an account, where \verb!<account>! is a string literal having the value of the address of an Ethereum account or a deployed smart contract, e.g. \verb!eth.getBalance("0x9afeD102A10D54Cc6C0E5153752c69B4876A7419")!

\item \verb!web3.toWei(<value>,<dimension>)! for getting the equivalent value in \emph{Wei}s of the specified amount, where \verb!<value>! is a number literal and \verb!<dimension>! is a string literal having the name of a valid etherum metic, e.g. \verb!web3.toWei(3.14,"ether")!

\item \verb!eth.getBlock(<block Number>)! for displaying the given block's data

\item \verb!eth.getTransaction(<block Number>)! for displaying the given transaction's data

\item \verb!eth.getGasPrice(console.log)! this function returns the median price of the last couple of executed transactions

\item \verb!eth.getTransactionCount(<account>,[<block specifier>])!, get the total transaction count for acount indicated by \verb!<account>!, optionally a block specifier can be supplied, e.g.: \\ \verb!eth.getTransactionCount("0x9afeD102A10D54Cc6C0E5153752c69B4876A7419","pending")! will get the transaction count for the given address including the pending transactions waiting in queue to be mined onto the blockchain

\item \verb!personal.signTransaction(<Transaction object>, <password>)! to sign a transaction with the senders private key represented by \verb!<Transaction object>! object where the sender's account has \verb!<password>! (string literal) as password, where a transaction has the following parameters

\begin{itemize}

\item \verb!from! : the sender's address

\item \verb!to! : the receiver's address

\item \verb!value! : the amount of \emph{Wei}s to be transferred to the receiver from the sender with this transaction

\item \verb!gas! : the amount of gas that can be consumed by the EVM for executing this transaction

\item \verb!gasPrice! : the price to be paid by the sender per units of gas consumed, the maximum price of the transaction will be \verb!value + gas*gasPrice!, if only fraction of the specified gas has been used by EVM, only the proportional price has to be paid while in contrast if the supplied gas was not enough the transaction will be reverted, but the gas price still has to be paid

\item \verb!nonce! : this is different from the block nonce in case of Proof-of-Work. This one indicates the total transaction count of the user in order to prevent double spending

\item \verb!data! : optional field, the additional data for this transaction, the code and data members are stored in this section of the transaction

\item Example:
\begin{lstlisting}[language=javascript,label=lst:transfer]
signedTransaction = personal.signTransaction({
    from: "0x9afeD102A10D54Cc6C0E5153752c69B4876A7419",
    to: "0x3FecF304285303Fba1C34124889Ea1256e9BB0de",
    value: web3.toWei(1,"ether"),
    gas: 200000, 
    gasPrice: 10,
    nonce: eth.getTransactionCount("0x9afeD102A10D54Cc6C0E5153752c69B4876A7419")
    },"user1" )
\end{lstlisting}

\end{itemize}

\item \verb!eth.sendRawTransaction(<Raw Transaction data>)! sends and execute the  provided transaction where \\ \verb!<Raw Transaction data>! is the raw transaction data in a hexadecimal string format, using the signed transaction object the raw transaction can be accessed by the \verb!raw! member variable, e.g.: \\ \verb!eth.sendRawTransaction(signedTransaction.raw)!

\end{itemize}

\subsection{PowerBid game}

\subsubsection{Description of the contract}
As part of familiarizing ourselves with the concepts of smart contracts and their potential use cases in IoT environments we are going to use a game. The game consists of a pre-implemented and simple smart contract that is modelling an electrical power auction. The game has 2 roles: supplier and consumer. The contract is created by the consumer where he specifies the required energy and the approximate time window where he intends to consume the required power. The creator - i.e. the consumer - of the contract also specifies a maximum price to pay for this amount of energy at that time window the he also has to pay upfront as a collateral to the deal. The suppliers essentially then monitor these contracts whether they can satisfy them while maximizing their profit then bid accordingly. This model is a sell auction i.e. a smaller price is considered more aggressive. 

The contract has been described in Solidity language and it's latest source that is used during this tutorial can be studied here: \url{https://raw.githubusercontent.com/fecjanky/iot_sc_tutorial/master/src/powerbid.sol}.

The contract has the following main phases:
\begin{enumerate}
    \item Auction Phase, where the suppliers participate in the sell auction
    \item Consumption Phase, where the consumer consumes the power paid and requested
    \item Withdraw Phase, where the consumer can withdraw his gain (that is the difference between the max. price and the best price) and the supplier can withdraw the funds from the contract
\end{enumerate}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{figures/state_diagram.png}
    \caption{The state diagram of the PowerBid smart contract}
    \label{fig:State-diagram-powerbid}
\end{figure}

\subsubsection{Deployment, bidding and evaluation}

The deployment of contract is done by supplying the required constructor parameters in the row where the \emph{Deploy} button is present. The transaction options are sourced from the corresponding \emph{TX Options} inputs and mapped to the transaction parameters as supplied in one of the previous tasks (see listing \ref{lst:transfer}. The deployment is initiated by clicking the \emph{Deploy} button. After successful deployment (see Figure \ref{fig:deploy-powerbid}) the new contract will appear under the deployed contracts list on the left hand side and will be selected as the active contract. In this case the transaction receipt will be logged in the bottom grey log area while in case of error the error message has to be inspected to see what went wrong with the deployment.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/ui-deploy.png}
    \caption{Deployment of a Powerbid contract}
    \label{fig:deploy-powerbid}
\end{figure}

The \emph{TX Options} are not mandatory in case of an arbitrary smart contract but as one inspects the constructor code (see listing \ref{lst:powerbid-ctor}) it can be seen that  the message value must be greater than 0 \emph{Wei} i.e. the creator of this smart contract must transfer some money upfront that is in line how the auction is modelled. The \emph{gas} and \emph{gasPrice} options are not mandatory, and in that case those are estimated automatically using the web3 API. 

\begin{lstlisting}[language=javascript,caption={Excerpt from the constructor of the Powerbid smart contract},label={lst:powerbid-ctor}]
    constructor(
        uint auctionPeriodSeconds,
        uint consumptionPeriodSeconds,
        uint requiredEnergy
    ) public payable {
        require(requiredEnergy > 0, "required energy must be greater than 0 wh");
        require(msg.value > 0 ,"max price must be greater than 0");
        require(auctionPeriodSeconds > 0, "auction period must be greater than 0");
        require(consumptionPeriodSeconds > 0, "consumption period must be greater than 0");
        consumer = msg.sender;
        ...
    }
\end{lstlisting}

As described before the \emph{gas} determines the amount of operations that can be performed by the virtual machine while executing a give smart contract API call and the \emph{gasPrice} times the used \emph{gas} will be the reward of the individual who successfully places the transaction in a block onto the canonical chain. For these exercises the \emph{gas} field can be left empty, however the \emph{gasPrice} should be specified as if it is missing it will be estimated based on the last few blocks median gas price and depending on the exchange values it can happen easily that the transaction costs more than the gained value resulting in a net balance decrease.

It's also worth mentioning that in case of a \verb!require! expression failure in the code when the transaction would be normally reverted the estimation will always fail with the same error message \emph{'gas required exceeds allowance (8000000) or always failing transaction'}, while if no estimation is needed - i.e. all options are specified, then the EVM will try to create the transaction, but it will result in a reversion due to the failed assertion with error \emph{'Transaction has been reverted by the EVM'} (see Figures \ref{fig:deploy-error-est} and \ref{fig:deploy-error-noest}). In both cases the contract's source code has to be studied for further troubleshooting. As of the time of this writing the \verb!require! expression's string parameter is not propagated to the user, but that can change in the future editions of the tool-chain as a consequence it is good practice to give meaningful diagnostics there.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/error-withestimation.png}
    \caption{Invalid parameters with estimation}
    \label{fig:deploy-error-noest}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/error-noestimation.png}
    \caption{Invalid parameters without estimation}
    \label{fig:deploy-error-est}
\end{figure}


After successful deployment the contract will show up on the left hand side listing. By clicking on a deployed contract it's controls will become visible. The auction and consumption time left fields are updated automatically, but the other fields have to be queried manually by either calling the corresponding API function (exposed as the adjacent button) or by clicking on the phase getter, that will call all non-mutable API functions. The functions that mutate the contract are marked red. The suppliers can use the \emph{bid} function to place their bids.

After the auction period has ended the consumption phase begins. The consumer can end the auction prematurely but in that case a different state transition sequence begins (see Figure \ref{fig:State-diagram-powerbid}.

After the consumption period has passed or the consumer explicitly marked the contract as consumed by clicking on the \emph{consumePower} button the contract is open for withdrawals. The amounts can be withdrawn in any order driving the contract into the \emph{Completed} state which is a terminal state.

\iffalse
\begin{enumerate}[label=\textbf{Task \arabic*}:,l_tasks]
\item After deploying a contract check its balance to clearly see that the money is upfront allocated. Observe the balance changes after every phase. \ref{lst:block}
\end{enumerate}
\fi
\subsubsection{Game-play summary}

The high-level game-play for the two different roles can be summarized as:
\begin{itemize}
    \item Consumer role:
    \begin{enumerate}
        \item Deploy contract after specifying the constructor parameters
        \item Monitor the sell auction until the auction is ongoing.
        \item Consume the power (virtually, calling the \emph{'consumePower'} API by pressing the corresponding button)
        \item withdraw gains (Max. price - best price)
        \item evaluate relative gain
    \end{enumerate}
    \item Producer/Supplier role:
    \begin{enumerate}
        \item Bid on the deployed Smart contracts
        \item monitor bid state based on the visual feedback and/or polling the contracts
        \item place further bids as desired
        \item wait for consumer to consume the power
        \item withdraw the price amount from the contracts that has been win by the user
        \item evaluate relative gain
    \end{enumerate}
\end{itemize}

\subsection{Implement a number guessing game}

\subsubsection{Specification}

The game participants are guessing numbers. The winner is who choose the smallest number. If a number has been chosen by more than 1 person it is not considered as a valid guess. 1 person can only guess once. The creator offers a prize that (greater than 0 Wei) is to be won by the winner. If at the end of the game there are no valid guesses the creator is considered the winner. Only the winner must be able to withdraw the prize. At construction time the owner should be able to specify the total number of guesses that will limit the number of individuals who are able to play the game. The prize mustn't be possible to be withdrawn before the game ends. The results should only be possible to be queried through the programmatic API when the game is over.

\subsubsection{Potential solution}

Since Solidity is nearly a Turing-complete programming language, several higher level abstractions can be built freely therefore there is no single solution for the specification above. A reference solution can be found here:

\noindent \url{https://raw.githubusercontent.com/fecjanky/iot_sc_tutorial/master/src/NumberGuessing.sol}

A key element of this solution is to provide iterability over the built-in \emph{mapping} type through a linear index to lookup key mapping. Furthermore, this sample solution illustrates the usage of \emph{storage} and \emph{memory} variable references.


\section*{Acknowledgements}
This Tutorial has been initially compiled for the audience of the

\noindent \emph{15th International Conference on Network and Service Management} -- technically co-sponsored by IFIP, IEEE Communication Society, IEEE Computer Society, and ACM.

In connection to this work, the authors have received funding  from  the  EU  ECSEL JU under the H2020 Framework Programme, JU grant nr.  737459  (Productive4.0  project,  www.productive40.eu).
Part of this work was supported by the Higher Education Excellence  Program  of  the  Ministry  of  Human  Capacities, Hungary, in the frame of Artificial Intelligence research area of Budapest University of Technology and Economics (BME FIKP-MI/SC). 

\newpage

\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}